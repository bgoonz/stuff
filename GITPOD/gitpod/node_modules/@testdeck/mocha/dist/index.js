"use strict";
const core = require("@testdeck/core");
function applyTimings(fn, settings) {
    if (settings) {
        if (fn.length === 1) {
            return core.wrap(function (done) {
                if (settings.retries !== undefined) {
                    this.retries(settings.retries);
                }
                if (settings.slow !== undefined) {
                    this.slow(settings.slow);
                }
                if (settings.timeout !== undefined) {
                    this.timeout(settings.timeout);
                }
                return fn.call(this, done);
            }, fn);
        }
        else {
            return core.wrap(function () {
                if (settings.retries !== undefined) {
                    this.retries(settings.retries);
                }
                if (settings.slow !== undefined) {
                    this.slow(settings.slow);
                }
                if (settings.timeout !== undefined) {
                    this.timeout(settings.timeout);
                }
                return fn.call(this);
            }, fn);
        }
    }
    else {
        return fn;
    }
}
const mochaRunner = {
    suite(name, callback, settings) {
        switch (settings && settings.execution) {
            case "only":
                describe.only(name, applyTimings(callback, settings));
                break;
            case "skip":
                describe.skip(name, applyTimings(callback, settings));
                break;
            case "pending":
                // `describe(name);` will not generate pending suite, intentionally skip.
                describe.skip(name, applyTimings(callback, settings));
                break;
            default:
                describe(name, applyTimings(callback, settings));
        }
    },
    test(name, callback, settings) {
        switch (settings && settings.execution) {
            case "only":
                it.only(name, applyTimings(callback, settings));
                break;
            case "skip":
                it.skip(name, applyTimings(callback, settings));
                break;
            case "pending":
                it(name);
                break;
            default:
                it(name, applyTimings(callback, settings));
        }
    },
    beforeAll(name, callback, settings) {
        before(applyTimings(callback, settings));
    },
    beforeEach(name, callback, settings) {
        beforeEach(applyTimings(callback, settings));
    },
    afterEach(name, callback, settings) {
        afterEach(applyTimings(callback, settings));
    },
    afterAll(name, callback, settings) {
        after(applyTimings(callback, settings));
    }
};
class MochaClassTestUI extends core.ClassTestUI {
    // TODO: skipOnError, @context
    constructor(runner = mochaRunner) {
        super(runner);
    }
}
const mochaDecorators = new MochaClassTestUI();
module.exports = mochaDecorators;
//# sourceMappingURL=index.js.map