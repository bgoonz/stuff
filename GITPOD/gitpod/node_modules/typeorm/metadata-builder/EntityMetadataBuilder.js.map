{"version":3,"sources":["../../src/metadata-builder/EntityMetadataBuilder.ts"],"names":[],"mappings":"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","file":"EntityMetadataBuilder.js","sourcesContent":["import {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {IndexMetadata} from \"../metadata/IndexMetadata\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\nimport {EmbeddedMetadata} from \"../metadata/EmbeddedMetadata\";\nimport {MetadataArgsStorage} from \"../metadata-args/MetadataArgsStorage\";\nimport {EmbeddedMetadataArgs} from \"../metadata-args/EmbeddedMetadataArgs\";\nimport {RelationIdMetadata} from \"../metadata/RelationIdMetadata\";\nimport {RelationCountMetadata} from \"../metadata/RelationCountMetadata\";\nimport {MetadataUtils} from \"./MetadataUtils\";\nimport {TableMetadataArgs} from \"../metadata-args/TableMetadataArgs\";\nimport {JunctionEntityMetadataBuilder} from \"./JunctionEntityMetadataBuilder\";\nimport {ClosureJunctionEntityMetadataBuilder} from \"./ClosureJunctionEntityMetadataBuilder\";\nimport {RelationJoinColumnBuilder} from \"./RelationJoinColumnBuilder\";\nimport {Connection} from \"../connection/Connection\";\nimport {EntityListenerMetadata} from \"../metadata/EntityListenerMetadata\";\nimport {ColumnOptions} from \"../decorator/options/ColumnOptions\";\nimport {ForeignKeyMetadata} from \"../metadata/ForeignKeyMetadata\";\nimport {LazyRelationsWrapper} from \"../lazy-loading/LazyRelationsWrapper\";\n\n/**\n * Builds EntityMetadata objects and all its sub-metadatas.\n */\nexport class EntityMetadataBuilder {\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Used to build entity metadatas of the junction entities.\n     */\n    protected junctionEntityMetadataBuilder: JunctionEntityMetadataBuilder;\n\n    /**\n     * Used to build entity metadatas of the closure junction entities.\n     */\n    protected closureJunctionEntityMetadataBuilder: ClosureJunctionEntityMetadataBuilder;\n\n    /**\n     * Used to build join columns of the relations.\n     */\n    protected relationJoinColumnBuilder: RelationJoinColumnBuilder;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: Connection,\n                private metadataArgsStorage: MetadataArgsStorage) {\n\n        this.junctionEntityMetadataBuilder = new JunctionEntityMetadataBuilder(connection);\n        this.closureJunctionEntityMetadataBuilder = new ClosureJunctionEntityMetadataBuilder(connection);\n        this.relationJoinColumnBuilder = new RelationJoinColumnBuilder(connection);\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds a complete entity metadatas for the given entity classes.\n     */\n    build(entityClasses?: Function[]): EntityMetadata[] {\n\n        // if entity classes to filter entities by are given then do filtering, otherwise use all\n        const allTables = entityClasses ? this.metadataArgsStorage.filterTables(entityClasses) : this.metadataArgsStorage.tables;\n\n        // filter out table metadata args for those we really create entity metadatas and tables in the db\n        const realTables = allTables.filter(table => table.type === \"regular\" || table.type === \"closure\" || table.type === \"class-table-child\" || table.type === \"single-table-child\");\n\n        // create entity metadatas for a user defined entities (marked with @Entity decorator or loaded from entity schemas)\n        const entityMetadatas = realTables.map(tableArgs => this.createEntityMetadata(tableArgs));\n\n        // calculate entity metadata computed properties and all its sub-metadatas\n        entityMetadatas.forEach(entityMetadata => this.computeEntityMetadata(entityMetadata));\n\n        // calculate entity metadata's inverse properties\n        entityMetadatas.forEach(entityMetadata => this.computeInverseProperties(entityMetadata, entityMetadatas));\n\n        // go through all entity metadatas and create foreign keys / junction entity metadatas for their relations\n        entityMetadatas\n            .filter(entityMetadata => entityMetadata.tableType !== \"single-table-child\")\n            .forEach(entityMetadata => {\n\n                // create entity's relations join columns (for many-to-one and one-to-one owner)\n                entityMetadata.relations.filter(relation => relation.isOneToOne || relation.isManyToOne).forEach(relation => {\n                    const joinColumns = this.metadataArgsStorage.filterJoinColumns(relation.target, relation.propertyName);\n                    const foreignKey = this.relationJoinColumnBuilder.build(joinColumns, relation); // create a foreign key based on its metadata args\n                    if (foreignKey) {\n                        relation.registerForeignKeys(foreignKey); // push it to the relation and thus register there a join column\n                        entityMetadata.foreignKeys.push(foreignKey);\n                    }\n                });\n\n                // create junction entity metadatas for entity many-to-many relations\n                entityMetadata.relations.filter(relation => relation.isManyToMany).forEach(relation => {\n                    const joinTable = this.metadataArgsStorage.findJoinTable(relation.target, relation.propertyName);\n                    if (!joinTable) return; // no join table set - no need to do anything (it means this is many-to-many inverse side)\n\n                    // here we create a junction entity metadata for a new junction table of many-to-many relation\n                    const junctionEntityMetadata = this.junctionEntityMetadataBuilder.build(relation, joinTable);\n                    relation.registerForeignKeys(...junctionEntityMetadata.foreignKeys);\n                    relation.registerJunctionEntityMetadata(junctionEntityMetadata);\n\n                    // compute new entity metadata properties and push it to entity metadatas pool\n                    this.computeEntityMetadata(junctionEntityMetadata);\n                    this.computeInverseProperties(junctionEntityMetadata, entityMetadatas);\n                    entityMetadatas.push(junctionEntityMetadata);\n                });\n\n                // update entity metadata depend properties\n                entityMetadata.relationsWithJoinColumns = entityMetadata.relations.filter(relation => relation.isWithJoinColumn);\n                entityMetadata.hasNonNullableRelations = entityMetadata.relationsWithJoinColumns.some(relation => !relation.isNullable || relation.isPrimary);\n        });\n\n        // generate closure junction tables for all closure tables\n        entityMetadatas\n            .filter(metadata => metadata.isClosure)\n            .forEach(entityMetadata => {\n                const closureJunctionEntityMetadata = this.closureJunctionEntityMetadataBuilder.build(entityMetadata);\n                entityMetadata.closureJunctionTable = closureJunctionEntityMetadata;\n                this.computeEntityMetadata(closureJunctionEntityMetadata);\n                this.computeInverseProperties(closureJunctionEntityMetadata, entityMetadatas);\n                entityMetadatas.push(closureJunctionEntityMetadata);\n            });\n\n        // after all metadatas created we set parent entity metadata for class-table inheritance\n        entityMetadatas\n            .filter(metadata => metadata.tableType === \"single-table-child\" || metadata.tableType === \"class-table-child\")\n            .forEach(entityMetadata => {\n                const inheritanceTree: any[] = entityMetadata.target instanceof Function\n                    ? MetadataUtils.getInheritanceTree(entityMetadata.target)\n                    : [entityMetadata.target];\n\n                const parentMetadata = entityMetadatas.find(metadata => {\n                    return inheritanceTree.find(inheritance => inheritance === metadata.target) && (metadata.inheritanceType === \"single-table\" || metadata.inheritanceType === \"class-table\");\n                });\n\n                if (parentMetadata) {\n                    entityMetadata.parentEntityMetadata = parentMetadata;\n                    if (parentMetadata.inheritanceType === \"single-table\")\n                        entityMetadata.tableName = parentMetadata.tableName;\n                }\n            });\n\n        // after all metadatas created we set child entity metadatas for class-table inheritance\n        entityMetadatas.forEach(metadata => {\n            metadata.childEntityMetadatas = entityMetadatas.filter(childMetadata => {\n                return metadata.target instanceof Function\n                    && childMetadata.target instanceof Function\n                    && MetadataUtils.isInherited(childMetadata.target, metadata.target);\n            });\n        });\n\n        // generate keys for tables with single-table inheritance\n        entityMetadatas\n            .filter(metadata => metadata.inheritanceType === \"single-table\" && metadata.discriminatorColumn)\n            .forEach(entityMetadata => this.createKeysForTableInheritance(entityMetadata));\n\n        // build all indices (need to do it after relations and their join columns are built)\n        entityMetadatas.forEach(entityMetadata => {\n            entityMetadata.indices.forEach(index => index.build(this.connection.namingStrategy));\n        });\n\n        entityMetadatas\n            .filter(metadata => !!metadata.parentEntityMetadata && metadata.tableType === \"class-table-child\")\n            .forEach(metadata => {\n                const parentPrimaryColumns = metadata.parentEntityMetadata.primaryColumns;\n                const parentRelationColumns = parentPrimaryColumns.map(parentPrimaryColumn => {\n                    const columnName = this.connection.namingStrategy.classTableInheritanceParentColumnName(metadata.parentEntityMetadata.tableName, parentPrimaryColumn.propertyPath);\n                    const column = new ColumnMetadata({\n                        connection: this.connection,\n                        entityMetadata: metadata,\n                        referencedColumn: parentPrimaryColumn,\n                        args: {\n                            target: metadata.target,\n                            propertyName: columnName,\n                            mode: \"parentId\",\n                            options: <ColumnOptions> {\n                                name: columnName,\n                                type: parentPrimaryColumn.type,\n                                unique: false,\n                                nullable: false,\n                                primary: true\n                            }\n                        }\n                    });\n                    metadata.registerColumn(column);\n                    column.build(this.connection);\n                    return column;\n                });\n\n                metadata.foreignKeys = [\n                    new ForeignKeyMetadata({\n                        entityMetadata: metadata,\n                        referencedEntityMetadata: metadata.parentEntityMetadata,\n                        namingStrategy: this.connection.namingStrategy,\n                        columns: parentRelationColumns,\n                        referencedColumns: parentPrimaryColumns,\n                        onDelete: \"CASCADE\"\n                    })\n                ];\n            });\n\n        // add lazy initializer for entity relations\n        entityMetadatas\n            .filter(metadata => metadata.target instanceof Function)\n            .forEach(entityMetadata => {\n                entityMetadata.relations\n                    .filter(relation => relation.isLazy)\n                    .forEach(relation => {\n                        const lazyRelationsWrapper = new LazyRelationsWrapper(this.connection);\n                        lazyRelationsWrapper.wrap((entityMetadata.target as Function).prototype, relation);\n                    });\n            });\n\n        entityMetadatas.forEach(entityMetadata => {\n            entityMetadata.columns.forEach(column => {\n                // const target = column.embeddedMetadata ? column.embeddedMetadata.type : column.target;\n                const generated = this.metadataArgsStorage.findGenerated(column.target, column.propertyName);\n                if (generated) {\n                    column.isGenerated = true;\n                    column.generationStrategy = generated.strategy;\n                    column.type = generated.strategy === \"increment\" ? (column.type || Number) : \"uuid\";\n                    column.build(this.connection);\n                    this.computeEntityMetadata(entityMetadata);\n                }\n            });\n\n        });\n\n        return entityMetadatas;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates entity metadata from the given table args.\n     * Creates column, relation, etc. metadatas for everything this entity metadata owns.\n     */\n    protected createEntityMetadata(tableArgs: TableMetadataArgs): EntityMetadata {\n\n        // we take all \"inheritance tree\" from a target entity to collect all stored metadata args\n        // (by decorators or inside entity schemas). For example for target Post < ContentModel < Unit\n        // it will be an array of [Post, ContentModel, Unit] and we can then get all metadata args of those classes\n        const inheritanceTree: any[] = tableArgs.target instanceof Function\n            ? MetadataUtils.getInheritanceTree(tableArgs.target)\n            : [tableArgs.target]; // todo: implement later here inheritance for string-targets\n\n        // if single table inheritance used, we need to copy all children columns in to parent table\n        let singleTableChildrenTargets: any[];\n        if (tableArgs.type === \"single-table-child\") {\n            singleTableChildrenTargets = this.metadataArgsStorage\n                .filterSingleTableChildren(tableArgs.target)\n                .map(args => args.target)\n                .filter(target => target instanceof Function);\n\n            inheritanceTree.push(...singleTableChildrenTargets);\n\n        } else if (tableArgs.type === \"class-table-child\") {\n            inheritanceTree.forEach(inheritanceTreeItem => {\n                const isParent = !!this.metadataArgsStorage.inheritances.find(i => i.target === inheritanceTreeItem);\n                if (isParent)\n                    inheritanceTree.splice(inheritanceTree.indexOf(inheritanceTreeItem), 1);\n            });\n        }\n\n        const entityMetadata = new EntityMetadata({\n            connection: this.connection,\n            args: tableArgs\n        });\n\n        const inheritanceType = this.metadataArgsStorage.findInheritanceType(tableArgs.target);\n        entityMetadata.inheritanceType = inheritanceType ? inheritanceType.type : undefined;\n\n        const discriminatorValue = this.metadataArgsStorage.findDiscriminatorValue(tableArgs.target);\n        entityMetadata.discriminatorValue = discriminatorValue ? discriminatorValue.value : (tableArgs.target as any).name; // todo: pass this to naming strategy to generate a name\n\n        entityMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(inheritanceTree));\n        entityMetadata.ownColumns = this.metadataArgsStorage\n            .filterColumns(inheritanceTree)\n            .map(args => {\n                const column = new ColumnMetadata({ connection: this.connection, entityMetadata, args });\n                // console.log(column.propertyName);\n                // if single table inheritance used, we need to mark all inherit table columns as nullable\n                if (singleTableChildrenTargets && singleTableChildrenTargets.indexOf(args.target) !== -1)\n                    column.isNullable = true;\n                return column;\n            });\n\n        entityMetadata.ownRelations = this.metadataArgsStorage.filterRelations(inheritanceTree).map(args => {\n            return new RelationMetadata({ entityMetadata, args });\n        });\n        entityMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(inheritanceTree).map(args => {\n            return new RelationIdMetadata({ entityMetadata, args });\n        });\n        entityMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(inheritanceTree).map(args => {\n            return new RelationCountMetadata({ entityMetadata, args });\n        });\n        entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(inheritanceTree).map(args => {\n            return new IndexMetadata({ entityMetadata, args });\n        });\n        entityMetadata.ownListeners = this.metadataArgsStorage.filterListeners(inheritanceTree).map(args => {\n            return new EntityListenerMetadata({ entityMetadata: entityMetadata, args: args });\n        });\n        return entityMetadata;\n    }\n\n    /**\n     * Creates from the given embedded metadata args real embedded metadatas with its columns and relations,\n     * and does the same for all its sub-embeddeds (goes recursively).\n     */\n    protected createEmbeddedsRecursively(entityMetadata: EntityMetadata, embeddedArgs: EmbeddedMetadataArgs[]): EmbeddedMetadata[] {\n        return embeddedArgs.map(embeddedArgs => {\n            const embeddedMetadata = new EmbeddedMetadata({ entityMetadata: entityMetadata, args: embeddedArgs });\n            const targets = MetadataUtils.getInheritanceTree(embeddedMetadata.type);\n\n            embeddedMetadata.columns = this.metadataArgsStorage.filterColumns(targets).map(args => {\n                return new ColumnMetadata({ connection: this.connection, entityMetadata, embeddedMetadata, args});\n            });\n            embeddedMetadata.relations = this.metadataArgsStorage.filterRelations(targets).map(args => {\n                return new RelationMetadata({ entityMetadata, embeddedMetadata, args });\n            });\n            embeddedMetadata.listeners = this.metadataArgsStorage.filterListeners(targets).map(args => {\n                return new EntityListenerMetadata({ entityMetadata, embeddedMetadata, args });\n            });\n            embeddedMetadata.indices = this.metadataArgsStorage.filterIndices(targets).map(args => {\n                return new IndexMetadata({ entityMetadata, embeddedMetadata, args });\n            });\n            embeddedMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(targets).map(args => {\n                return new RelationIdMetadata({ entityMetadata, args });\n            });\n            embeddedMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(targets).map(args => {\n                return new RelationCountMetadata({ entityMetadata, args });\n            });\n            embeddedMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(targets));\n            embeddedMetadata.embeddeds.forEach(subEmbedded => subEmbedded.parentEmbeddedMetadata = embeddedMetadata);\n            return embeddedMetadata;\n        });\n    }\n\n    /**\n     * Computes all entity metadata's computed properties, and all its sub-metadatas (relations, columns, embeds, etc).\n     */\n    protected computeEntityMetadata(entityMetadata: EntityMetadata) {\n        entityMetadata.embeddeds.forEach(embedded => embedded.build(this.connection));\n        entityMetadata.embeddeds.forEach(embedded => {\n            embedded.columnsFromTree.forEach(column => column.build(this.connection));\n            embedded.relationsFromTree.forEach(relation => relation.build());\n        });\n        entityMetadata.ownColumns.forEach(column => column.build(this.connection));\n        entityMetadata.ownRelations.forEach(relation => relation.build());\n        entityMetadata.relations = entityMetadata.embeddeds.reduce((relations, embedded) => relations.concat(embedded.relationsFromTree), entityMetadata.ownRelations);\n        entityMetadata.eagerRelations = entityMetadata.relations.filter(relation => relation.isEager);\n        entityMetadata.lazyRelations = entityMetadata.relations.filter(relation => relation.isLazy);\n        entityMetadata.oneToOneRelations = entityMetadata.relations.filter(relation => relation.isOneToOne);\n        entityMetadata.oneToManyRelations = entityMetadata.relations.filter(relation => relation.isOneToMany);\n        entityMetadata.manyToOneRelations = entityMetadata.relations.filter(relation => relation.isManyToOne);\n        entityMetadata.manyToManyRelations = entityMetadata.relations.filter(relation => relation.isManyToMany);\n        entityMetadata.ownerOneToOneRelations = entityMetadata.relations.filter(relation => relation.isOneToOneOwner);\n        entityMetadata.ownerManyToManyRelations = entityMetadata.relations.filter(relation => relation.isManyToManyOwner);\n        entityMetadata.treeParentRelation = entityMetadata.relations.find(relation => relation.isTreeParent);\n        entityMetadata.treeChildrenRelation = entityMetadata.relations.find(relation => relation.isTreeChildren);\n        entityMetadata.columns = entityMetadata.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), entityMetadata.ownColumns);\n        entityMetadata.listeners = entityMetadata.embeddeds.reduce((columns, embedded) => columns.concat(embedded.listenersFromTree), entityMetadata.ownListeners);\n        entityMetadata.indices = entityMetadata.embeddeds.reduce((columns, embedded) => columns.concat(embedded.indicesFromTree), entityMetadata.ownIndices);\n        entityMetadata.primaryColumns = entityMetadata.columns.filter(column => column.isPrimary);\n        entityMetadata.hasMultiplePrimaryKeys = entityMetadata.primaryColumns.length > 1;\n        entityMetadata.generatedColumns = entityMetadata.columns.filter(column => column.isGenerated || column.isObjectId);\n        entityMetadata.createDateColumn = entityMetadata.columns.find(column => column.isCreateDate);\n        entityMetadata.updateDateColumn = entityMetadata.columns.find(column => column.isUpdateDate);\n        entityMetadata.versionColumn = entityMetadata.columns.find(column => column.isVersion);\n        entityMetadata.discriminatorColumn = entityMetadata.columns.find(column => column.isDiscriminator);\n        entityMetadata.treeLevelColumn = entityMetadata.columns.find(column => column.isTreeLevel);\n        entityMetadata.parentIdColumns = entityMetadata.columns.filter(column => column.isParentId);\n        entityMetadata.objectIdColumn = entityMetadata.columns.find(column => column.isObjectId);\n        entityMetadata.foreignKeys.forEach(foreignKey => foreignKey.build(this.connection.namingStrategy));\n        entityMetadata.propertiesMap = entityMetadata.createPropertiesMap();\n        entityMetadata.relationIds.forEach(relationId => relationId.build());\n        entityMetadata.relationCounts.forEach(relationCount => relationCount.build());\n        entityMetadata.embeddeds.forEach(embedded => {\n            embedded.relationIdsFromTree.forEach(relationId => relationId.build());\n            embedded.relationCountsFromTree.forEach(relationCount => relationCount.build());\n        });\n    }\n\n    /**\n     * Computes entity metadata's relations inverse side properties.\n     */\n    protected computeInverseProperties(entityMetadata: EntityMetadata, entityMetadatas: EntityMetadata[]) {\n        entityMetadata.relations.forEach(relation => {\n\n            // compute inverse side (related) entity metadatas for all relation metadatas\n            const inverseEntityMetadata = entityMetadatas.find(m => m.target === relation.type || (typeof relation.type === \"string\" && m.targetName === relation.type));\n            if (!inverseEntityMetadata)\n                throw new Error(\"Entity metadata for \" + entityMetadata.name + \"#\" + relation.propertyPath + \" was not found. Check if you specified a correct entity object, check its really entity and its connected in the connection options.\");\n\n            relation.inverseEntityMetadata = inverseEntityMetadata;\n            relation.inverseSidePropertyPath = relation.buildInverseSidePropertyPath();\n\n            // and compute inverse relation and mark if it has such\n            relation.inverseRelation = inverseEntityMetadata.relations.find(foundRelation => foundRelation.propertyPath === relation.inverseSidePropertyPath);\n        });\n    }\n\n    /**\n     * Creates indices for the table of single table inheritance.\n     */\n    protected createKeysForTableInheritance(entityMetadata: EntityMetadata) {\n        entityMetadata.indices.push(\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: [entityMetadata.discriminatorColumn!],\n                args: {\n                    target: entityMetadata.target,\n                    unique: false\n                }\n            }),\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: [...entityMetadata.primaryColumns, entityMetadata.discriminatorColumn!],\n                args: {\n                    target: entityMetadata.target,\n                    unique: false\n                }\n            })\n        );\n    }\n\n}\n\n// generate virtual column with foreign key for class-table inheritance\n/*entityMetadatas.forEach(entityMetadata => {\n if (!entityMetadata.parentEntityMetadata)\n return;\n\n const parentPrimaryColumns = entityMetadata.parentEntityMetadata.primaryColumns;\n const parentIdColumns = parentPrimaryColumns.map(primaryColumn => {\n const columnName = this.namingStrategy.classTableInheritanceParentColumnName(entityMetadata.parentEntityMetadata.tableName, primaryColumn.propertyName);\n const column = new ColumnMetadataBuilder(entityMetadata);\n column.type = primaryColumn.type;\n column.propertyName = primaryColumn.propertyName; // todo: check why needed\n column.givenName = columnName;\n column.mode = \"parentId\";\n column.isUnique = true;\n column.isNullable = false;\n // column.entityTarget = entityMetadata.target;\n return column;\n });\n\n // add foreign key\n const foreignKey = new ForeignKeyMetadataBuilder(\n entityMetadata,\n parentIdColumns,\n entityMetadata.parentEntityMetadata,\n parentPrimaryColumns,\n \"CASCADE\"\n );\n entityMetadata.ownColumns.push(...parentIdColumns);\n entityMetadata.foreignKeys.push(foreignKey);\n });*/\n\n\n/*protected createEntityMetadata(metadata: EntityMetadata, options: {\n userSpecifiedTableName?: string,\n closureOwnerTableName?: string,\n }) {\n\n const tableNameUserSpecified = options.userSpecifiedTableName;\n const isClosureJunction = metadata.tableType === \"closure-junction\";\n const targetName = metadata.target instanceof Function ? (metadata.target as any).name : metadata.target;\n const tableNameWithoutPrefix = isClosureJunction\n ? this.namingStrategy.closureJunctionTableName(options.closureOwnerTableName!)\n : this.namingStrategy.tableName(targetName, options.userSpecifiedTableName);\n\n const tableName = this.namingStrategy.prefixTableName(this.driver.options.tablesPrefix, tableNameWithoutPrefix);\n\n // for virtual tables (like junction table) target is equal to undefined at this moment\n // we change this by setting virtual's table name to a target name\n // todo: add validation so targets with same schema names won't conflicts with virtual table names\n metadata.target = metadata.target ? metadata.target : tableName;\n metadata.targetName = targetName;\n metadata.givenTableName = tableNameUserSpecified;\n metadata.tableNameWithoutPrefix = tableNameWithoutPrefix;\n metadata.tableName = tableName;\n metadata.name = targetName ? targetName : tableName;\n // metadata.namingStrategy = this.namingStrategy;\n }*/\n\n/*protected createEntityMetadata(tableArgs: any, argsForTable: any, ): EntityMetadata {\n const metadata = new EntityMetadata({\n junction: false,\n target: tableArgs.target,\n tablesPrefix: this.driver.options.tablesPrefix,\n namingStrategy: this.namingStrategy,\n tableName: argsForTable.name,\n tableType: argsForTable.type,\n orderBy: argsForTable.orderBy,\n engine: argsForTable.engine,\n skipSchemaSync: argsForTable.skipSchemaSync,\n columnMetadatas: columns,\n relationMetadatas: relations,\n relationIdMetadatas: relationIds,\n relationCountMetadatas: relationCounts,\n indexMetadatas: indices,\n embeddedMetadatas: embeddeds,\n inheritanceType: mergedArgs.inheritance ? mergedArgs.inheritance.type : undefined,\n discriminatorValue: discriminatorValueArgs ? discriminatorValueArgs.value : (tableArgs.target as any).name // todo: pass this to naming strategy to generate a name\n }, this.lazyRelationsWrapper);\n return metadata;\n }*/\n\n\n// const tables = [mergedArgs.table].concat(mergedArgs.children);\n// tables.forEach(tableArgs => {\n\n// find embeddable tables for embeddeds registered in this table and create EmbeddedMetadatas from them\n// const findEmbeddedsRecursively = (embeddedArgs: EmbeddedMetadataArgs[]) => {\n//     const embeddeds: EmbeddedMetadata[] = [];\n//     embeddedArgs.forEach(embedded => {\n//         const embeddableTable = embeddableMergedArgs.find(embeddedMergedArgs => embeddedMergedArgs.table.target === embedded.type());\n//         if (embeddableTable) {\n//             const columns = embeddableTable.columns.toArray().map(args => new ColumnMetadata(args));\n//             const relations = embeddableTable.relations.toArray().map(args => new RelationMetadata(args));\n//             const subEmbeddeds = findEmbeddedsRecursively(embeddableTable.embeddeds.toArray());\n//             embeddeds.push(new EmbeddedMetadata(columns, relations, subEmbeddeds, embedded));\n//         }\n//     });\n//     return embeddeds;\n// };\n// const embeddeds = findEmbeddedsRecursively(mergedArgs.embeddeds.toArray());\n\n// create metadatas from args\n// const argsForTable = mergedArgs.inheritance && mergedArgs.inheritance.type === \"single-table\" ? mergedArgs.table : tableArgs;\n\n// const table = new TableMetadata(argsForTable);\n// const columns = mergedArgs.columns.toArray().map(args => {\n//\n//     // if column's target is a child table then this column should have all nullable columns\n//     if (mergedArgs.inheritance &&\n//         mergedArgs.inheritance.type === \"single-table\" &&\n//         args.target !== mergedArgs.table.target && !!mergedArgs.children.find(childTable => childTable.target === args.target)) {\n//         args.options.nullable = true;\n//     }\n//     return new ColumnMetadata(args);\n// });\n// const discriminatorValueArgs = mergedArgs.discriminatorValues.find(discriminatorValueArgs => {\n//     return discriminatorValueArgs.target === tableArgs.target;\n// });\n\n\n\n// after all metadatas created we set parent entity metadata for class-table inheritance\n// entityMetadatas.forEach(entityMetadata => {\n//     const mergedArgs = realTables.find(args => args.target === entityMetadata.target);\n//     if (mergedArgs && mergedArgs.parent) {\n//         const parentEntityMetadata = entityMetadatas.find(entityMetadata => entityMetadata.target === (mergedArgs!.parent! as any).target); // todo: weird compiler error here, thats why type casing is used\n//         if (parentEntityMetadata)\n//             entityMetadata.parentEntityMetadata = parentEntityMetadata;\n//     }\n// });"],"sourceRoot":".."}