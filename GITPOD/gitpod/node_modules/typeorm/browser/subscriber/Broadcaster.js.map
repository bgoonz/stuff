{"version":3,"sources":["../browser/src/subscriber/Broadcaster.ts"],"names":[],"mappings":"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","file":"Broadcaster.js","sourcesContent":["import {EntitySubscriberInterface} from \"./EntitySubscriberInterface\";\nimport {EventListenerTypes} from \"../metadata/types/EventListenerTypes\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {Subject} from \"../persistence/Subject\";\nimport {Connection} from \"../connection/Connection\";\nimport {EntityManager} from \"../entity-manager/EntityManager\";\n\n/**\n * Broadcaster provides a helper methods to broadcast events to the subscribers.\n */\nexport class Broadcaster {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: Connection) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\" events for all given subjects.\n     */\n    async broadcastBeforeEventsForAll(entityManager: EntityManager, insertSubjects: Subject[], updateSubjects: Subject[], removeSubjects: Subject[]): Promise<void> {\n        const insertPromises = insertSubjects.map(subject => this.broadcastBeforeInsertEvent(entityManager, subject));\n        const updatePromises = updateSubjects.map(subject => this.broadcastBeforeUpdateEvent(entityManager, subject));\n        const removePromises = removeSubjects.map(subject => this.broadcastBeforeRemoveEvent(entityManager, subject));\n        const allPromises = insertPromises.concat(updatePromises).concat(removePromises);\n        await Promise.all(allPromises);\n    }\n\n    /**\n     * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\" events for all given subjects.\n     */\n    async broadcastAfterEventsForAll(entityManager: EntityManager, insertSubjects: Subject[], updateSubjects: Subject[], removeSubjects: Subject[]): Promise<void> {\n        const insertPromises = insertSubjects.map(subject => this.broadcastAfterInsertEvent(entityManager, subject));\n        const updatePromises = updateSubjects.map(subject => this.broadcastAfterUpdateEvent(entityManager, subject));\n        const removePromises = removeSubjects.map(subject => this.broadcastAfterRemoveEvent(entityManager, subject));\n        const allPromises = insertPromises.concat(updatePromises).concat(removePromises);\n        await Promise.all(allPromises);\n    }\n\n    /**\n     * Broadcasts \"BEFORE_INSERT\" event.\n     * Before insert event is executed before entity is being inserted to the database for the first time.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     */\n    async broadcastBeforeInsertEvent(manager: EntityManager, subject: Subject): Promise<void> {\n\n        const listeners = subject.metadata.listeners\n            .filter(listener => listener.type === EventListenerTypes.BEFORE_INSERT && listener.isAllowed(subject.entity))\n            .map(entityListener => entityListener.execute(subject.entity));\n\n        const subscribers = this.connection.subscribers\n            .filter(subscriber => this.isAllowedSubscriber(subscriber, subject.entityTarget!) && subscriber.beforeInsert)\n            .map(subscriber => subscriber.beforeInsert!({\n                manager: manager,\n                entity: subject.entity\n            }));\n\n        await Promise.all(listeners.concat(subscribers));\n    }\n\n    /**\n     * Broadcasts \"BEFORE_UPDATE\" event.\n     * Before update event is executed before entity is being updated in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     */\n    async broadcastBeforeUpdateEvent(manager: EntityManager, subject: Subject): Promise<void> { // todo: send relations too?\n\n        const listeners = subject.metadata.listeners\n            .filter(listener => listener.type === EventListenerTypes.BEFORE_UPDATE && listener.isAllowed(subject.entity))\n            .map(entityListener => entityListener.execute(subject.entity));\n\n        const subscribers = this.connection.subscribers\n            .filter(subscriber => this.isAllowedSubscriber(subscriber, subject.entityTarget!) && subscriber.beforeUpdate)\n            .map(subscriber => subscriber.beforeUpdate!({\n                manager: manager,\n                entity: subject.entity,\n                databaseEntity: subject.databaseEntity,\n                updatedColumns: subject.diffColumns,\n                updatedRelations: subject.diffRelations,\n            }));\n\n        await Promise.all(listeners.concat(subscribers));\n    }\n\n    /**\n     * Broadcasts \"BEFORE_REMOVE\" event.\n     * Before remove event is executed before entity is being removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     */\n    async broadcastBeforeRemoveEvent(manager: EntityManager, subject: Subject): Promise<void> {\n\n        const listeners = subject.metadata.listeners\n            .filter(listener => listener.type === EventListenerTypes.BEFORE_REMOVE && listener.isAllowed(subject.entity))\n            .map(entityListener => entityListener.execute(subject.databaseEntity));\n\n        const subscribers = this.connection.subscribers\n            .filter(subscriber => this.isAllowedSubscriber(subscriber, subject.entityTarget!) && subscriber.beforeRemove)\n            .map(subscriber => subscriber.beforeRemove!({\n                manager: manager,\n                entity: subject.hasEntity ? subject.entity : undefined,\n                databaseEntity: subject.databaseEntity,\n                entityId: subject.metadata.getEntityIdMixedMap(subject.databaseEntity)\n            }));\n\n        await Promise.all(listeners.concat(subscribers));\n    }\n\n    /**\n     * Broadcasts \"AFTER_INSERT\" event.\n     * After insert event is executed after entity is being persisted to the database for the first time.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     */\n    async broadcastAfterInsertEvent(manager: EntityManager, subject: Subject): Promise<void> {\n\n        const listeners = subject.metadata.listeners\n            .filter(listener => listener.type === EventListenerTypes.AFTER_INSERT && listener.isAllowed(subject.entity))\n            .map(entityListener => entityListener.execute(subject.entity));\n\n        const subscribers = this.connection.subscribers\n            .filter(subscriber => this.isAllowedSubscriber(subscriber, subject.entityTarget!) && subscriber.afterInsert)\n            .map(subscriber => subscriber.afterInsert!({\n                manager: manager,\n                entity: subject.entity\n            }));\n\n        await Promise.all(listeners.concat(subscribers));\n    }\n\n    /**\n     * Broadcasts \"AFTER_UPDATE\" event.\n     * After update event is executed after entity is being updated in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     */\n    async broadcastAfterUpdateEvent(manager: EntityManager, subject: Subject): Promise<void> {\n\n        const listeners = subject.metadata.listeners\n            .filter(listener => listener.type === EventListenerTypes.AFTER_UPDATE && listener.isAllowed(subject.entity))\n            .map(entityListener => entityListener.execute(subject.entity));\n\n        const subscribers = this.connection.subscribers\n            .filter(subscriber => this.isAllowedSubscriber(subscriber, subject.entityTarget!) && subscriber.afterUpdate)\n            .map(subscriber => subscriber.afterUpdate!({\n                manager: manager,\n                entity: subject.entity,\n                databaseEntity: subject.databaseEntity,\n                updatedColumns: subject.diffColumns,\n                updatedRelations: subject.diffRelations,\n            }));\n\n        await Promise.all(listeners.concat(subscribers));\n    }\n\n    /**\n     * Broadcasts \"AFTER_REMOVE\" event.\n     * After remove event is executed after entity is being removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     */\n    async broadcastAfterRemoveEvent(manager: EntityManager, subject: Subject): Promise<void> {\n\n        const listeners = subject.metadata.listeners\n            .filter(listener => listener.type === EventListenerTypes.AFTER_REMOVE && listener.isAllowed(subject.entity))\n            .map(entityListener => entityListener.execute(subject.entity));\n\n        const subscribers = this.connection.subscribers\n            .filter(subscriber => this.isAllowedSubscriber(subscriber, subject.entityTarget!) && subscriber.afterRemove)\n            .map(subscriber => subscriber.afterRemove!({\n                manager: manager,\n                entity: subject.hasEntity ? subject.entity : undefined,\n                databaseEntity: subject.databaseEntity,\n                entityId: subject.metadata.getEntityIdMixedMap(subject.databaseEntity)\n            }));\n\n        await Promise.all(listeners.concat(subscribers));\n    }\n\n    /**\n     * Broadcasts \"AFTER_LOAD\" event for all given entities, and their sub-entities.\n     * After load event is executed after entity has been loaded from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     */\n    async broadcastLoadEventsForAll(target: Function|string, entities: ObjectLiteral[]): Promise<void> {\n        await Promise.all(entities.map(entity => this.broadcastLoadEvents(target, entity)));\n    }\n\n    /**\n     * Broadcasts \"AFTER_LOAD\" event for the given entity and all its sub-entities.\n     * After load event is executed after entity has been loaded from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     */\n    async broadcastLoadEvents(target: Function|string, entity: ObjectLiteral): Promise<void> {\n        if (entity instanceof Promise) // todo: check why need this?\n            return;\n\n        // collect load events for all children entities that were loaded with the main entity\n        const children = this.connection.getMetadata(target).relations.reduce((promises, relation) => {\n\n            // in lazy relations we cannot simply access to entity property because it will cause a getter and a database query\n            if (relation.isLazy) {\n                if (!entity.hasOwnProperty(relation.propertyName))\n                    return promises;\n            } else {\n                if (entity[relation.propertyName] === null || entity[relation.propertyName] === undefined)\n                    return promises;\n            }\n\n            const value = relation.getEntityValue(entity);\n            if (value instanceof Array) {\n                promises = promises.concat(this.broadcastLoadEventsForAll(relation.inverseEntityMetadata.target!, value));\n            } else if (value) {\n                promises.push(this.broadcastLoadEvents(relation.inverseEntityMetadata.target!, value));\n            }\n\n            return promises;\n        }, [] as Promise<void>[]);\n\n        const listeners = this.connection.getMetadata(target).listeners\n            .filter(listener => listener.type === EventListenerTypes.AFTER_LOAD && listener.isAllowed(entity))\n            .map(listener => entity[listener.propertyName]());\n\n        const subscribers = this.connection.subscribers\n            .filter(subscriber => this.isAllowedSubscriber(subscriber, target) && subscriber.afterLoad)\n            .map(subscriber => subscriber.afterLoad!(entity));\n\n        await Promise.all(children.concat(listeners.concat(subscribers)));\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,\n     * or listens our entity.\n     */\n    protected isAllowedSubscriber(subscriber: EntitySubscriberInterface<any>, target: Function|string): boolean {\n        return  !subscriber.listenTo ||\n                !subscriber.listenTo() ||\n                subscriber.listenTo() === Object ||\n                subscriber.listenTo() === target ||\n                subscriber.listenTo().isPrototypeOf(target);\n    }\n\n}"],"sourceRoot":".."}