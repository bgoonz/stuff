{"version":3,"sources":["../../src/metadata/ColumnMetadata.ts"],"names":[],"mappings":"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","file":"ColumnMetadata.js","sourcesContent":["import {ColumnType} from \"../driver/types/ColumnTypes\";\nimport {EntityMetadata} from \"./EntityMetadata\";\nimport {EmbeddedMetadata} from \"./EmbeddedMetadata\";\nimport {RelationMetadata} from \"./RelationMetadata\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {ColumnMetadataArgs} from \"../metadata-args/ColumnMetadataArgs\";\nimport {Connection} from \"../connection/Connection\";\nimport {OrmUtils} from \"../util/OrmUtils\";\nimport {ValueTransformer} from \"../decorator/options/ValueTransformer\";\n\n/**\n * This metadata contains all information about entity's column.\n */\nexport class ColumnMetadata {\n\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Target class where column decorator is used.\n     * This may not be always equal to entity metadata (for example embeds or inheritance cases).\n     */\n    target: Function|string;\n\n    /**\n     * Entity metadata where this column metadata is.\n     *\n     * For example for @Column() name: string in Post, entityMetadata will be metadata of Post entity.\n     */\n    entityMetadata: EntityMetadata;\n\n    /**\n     * Embedded metadata where this column metadata is.\n     * If this column is not in embed then this property value is undefined.\n     */\n    embeddedMetadata?: EmbeddedMetadata;\n\n    /**\n     * If column is a foreign key of some relation then this relation's metadata will be there.\n     * If this column does not have a foreign key then this property value is undefined.\n     */\n    relationMetadata?: RelationMetadata;\n\n    /**\n     * Class's property name on which this column is applied.\n     */\n    propertyName: string;\n\n    /**\n     * The database type of the column.\n     */\n    type: ColumnType;\n\n    /**\n     * Type's length in the database.\n     */\n    length: string = \"\";\n\n    /**\n     * Defines column character set.\n     */\n    charset?: string;\n\n    /**\n     * Defines column collation.\n     */\n    collation?: string;\n\n    /**\n     * Indicates if this column is a primary key.\n     */\n    isPrimary: boolean = false;\n\n    /**\n     * Indicates if this column is generated (auto increment or generated other way).\n     */\n    isGenerated: boolean = false;\n\n    /**\n     * Specifies generation strategy if this column will use auto increment.\n     */\n    generationStrategy: \"uuid\"|\"increment\";\n\n    /**\n     * Indicates if column value in the database should be unique or not.\n     */\n    isUnique: boolean = false;\n\n    /**\n     * Indicates if column can contain nulls or not.\n     */\n    isNullable: boolean = false;\n\n    /**\n     * Indicates if column is selected by query builder or not.\n     */\n    isSelect: boolean = true;\n\n    /**\n     * Indicates if column is protected from updates or not.\n     */\n    isReadonly: boolean = false;\n\n    /**\n     * Column comment.\n     * This feature is not supported by all databases.\n     */\n    comment: string = \"\";\n\n    /**\n     * Default database value.\n     */\n    default?: any;\n\n    /**\n     * The precision for a decimal (exact numeric) column (applies only for decimal column),\n     * which is the maximum number of digits that are stored for the values.\n     */\n    precision?: number;\n\n    /**\n     * The scale for a decimal (exact numeric) column (applies only for decimal column),\n     * which represents the number of digits to the right of the decimal point and must not be greater than precision.\n     */\n    scale?: number;\n\n    /**\n     * Array of possible enumerated values.\n     */\n    enum?: any[];\n\n    /**\n     * Indicates if this column is an array.\n     * Can be simply set to true or array length can be specified.\n     * Supported only by postgres.\n     */\n    isArray?: boolean;\n\n    /**\n     * Gets full path to this column property (including column property name).\n     * Full path is relevant when column is used in embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters.likes\".\n     * If property is not in embeds then it returns just property name of the column.\n     */\n    propertyPath: string;\n\n    /**\n     * Complete column name in the database including its embedded prefixes.\n     */\n    databaseName: string;\n\n    /**\n     * Database name in the database without embedded prefixes applied.\n     */\n    databaseNameWithoutPrefixes: string;\n\n    /**\n     * Database name set by entity metadata builder, not yet passed naming strategy process and without embedded prefixes.\n     */\n    givenDatabaseName?: string;\n\n    /**\n     * Indicates if column is virtual. Virtual columns are not mapped to the entity.\n     */\n    isVirtual: boolean = false;\n\n    /**\n     * Indicates if column is a parent id. Parent id columns are not mapped to the entity.\n     */\n    isParentId: boolean = false;\n\n    /**\n     * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.\n     */\n    isDiscriminator: boolean = false;\n\n    /**\n     * Indicates if column is tree-level column. Tree-level columns are used in closure entities.\n     */\n    isTreeLevel: boolean = false;\n\n    /**\n     * Indicates if this column contains an entity creation date.\n     */\n    isCreateDate: boolean = false;\n\n    /**\n     * Indicates if this column contains an entity update date.\n     */\n    isUpdateDate: boolean = false;\n\n    /**\n     * Indicates if this column contains an entity version.\n     */\n    isVersion: boolean = false;\n\n    /**\n     * Indicates if this column contains an object id.\n     */\n    isObjectId: boolean = false;\n\n    /**\n     * If this column is foreign key then it references some other column,\n     * and this property will contain reference to this column.\n     */\n    referencedColumn: ColumnMetadata|undefined;\n\n    /**\n     * Specifies a value transformer that is to be used to (un)marshal\n     * this column when reading or writing to the database.\n     */\n    transformer?: ValueTransformer;\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        connection: Connection,\n        entityMetadata: EntityMetadata,\n        embeddedMetadata?: EmbeddedMetadata,\n        referencedColumn?: ColumnMetadata,\n        args: ColumnMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata;\n        this.embeddedMetadata = options.embeddedMetadata!;\n        this.referencedColumn = options.referencedColumn;\n        if (options.args.target)\n            this.target = options.args.target;\n        if (options.args.propertyName)\n            this.propertyName = options.args.propertyName;\n        if (options.args.options.name)\n            this.givenDatabaseName = options.args.options.name;\n        if (options.args.options.type)\n            this.type = options.args.options.type;\n        if (options.args.options.length)\n            this.length = options.args.options.length ? options.args.options.length.toString() : \"\";\n        if (options.args.options.charset)\n            this.charset = options.args.options.charset;\n        if (options.args.options.collation)\n            this.collation = options.args.options.collation;\n        if (options.args.options.primary)\n            this.isPrimary = options.args.options.primary;\n        if (options.args.options.unique)\n            this.isUnique = options.args.options.unique;\n        if (options.args.options.default === null) // to make sure default: null is the same as nullable: true\n            this.isNullable = true;\n        if (options.args.options.nullable !== undefined)\n            this.isNullable = options.args.options.nullable;\n        if (options.args.options.select !== undefined)\n            this.isSelect = options.args.options.select;\n        if (options.args.options.readonly !== undefined)\n            this.isReadonly = options.args.options.readonly;\n        if (options.args.options.comment)\n            this.comment = options.args.options.comment;\n        if (options.args.options.default !== undefined)\n            this.default = options.args.options.default;\n        if (options.args.options.scale)\n            this.scale = options.args.options.scale;\n        if (options.args.options.precision)\n            this.precision = options.args.options.precision;\n        if (options.args.options.enum) {\n            if (options.args.options.enum instanceof Object) {\n                this.enum = Object.keys(options.args.options.enum).map(key => {\n                    return (options.args.options.enum as ObjectLiteral)[key];\n                });\n\n            } else {\n                this.enum = options.args.options.enum;\n            }\n        }\n        if (options.args.options.isArray)\n            this.isArray = options.args.options.isArray;\n        if (options.args.options.array)\n            this.isArray = options.args.options.array;\n        if (options.args.mode) {\n            this.isVirtual = options.args.mode === \"virtual\";\n            this.isParentId = options.args.mode === \"parentId\";\n            this.isDiscriminator = options.args.mode === \"discriminator\";\n            this.isTreeLevel = options.args.mode === \"treeLevel\";\n            this.isCreateDate = options.args.mode === \"createDate\";\n            this.isUpdateDate = options.args.mode === \"updateDate\";\n            this.isVersion = options.args.mode === \"version\";\n            this.isObjectId = options.args.mode === \"objectId\";\n        }\n        if (options.args.options.transformer)\n            this.transformer = options.args.options.transformer;\n        if (this.isTreeLevel)\n            this.type = options.connection.driver.mappedDataTypes.treeLevel;\n        if (this.isCreateDate) {\n            this.type = options.connection.driver.mappedDataTypes.createDate;\n            if (!this.default)\n                this.default = () => options.connection.driver.mappedDataTypes.createDateDefault;\n            if (!this.precision && options.connection.driver.mappedDataTypes.createDatePrecision)\n                this.precision = options.connection.driver.mappedDataTypes.createDatePrecision;\n        }\n        if (this.isUpdateDate) {\n            this.type = options.connection.driver.mappedDataTypes.updateDate;\n            if (!this.default)\n                this.default = () => options.connection.driver.mappedDataTypes.updateDateDefault;\n            if (!this.precision && options.connection.driver.mappedDataTypes.updateDatePrecision)\n                this.precision = options.connection.driver.mappedDataTypes.updateDatePrecision;\n        }\n        if (this.isVersion)\n            this.type = options.connection.driver.mappedDataTypes.version;\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Creates entity id map from the given entity ids array.\n     */\n    createValueMap(value: any) {\n\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (propertyNames: string[], map: ObjectLiteral): any => {\n                const propertyName = propertyNames.shift();\n                if (propertyName) {\n                    map[propertyName] = {};\n                    extractEmbeddedColumnValue(propertyNames, map[propertyName]);\n                    return map;\n                }\n\n                // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n                if (this.generationStrategy === \"increment\" && this.type === \"bigint\")\n                    value = String(value);\n\n                map[this.propertyName] = value;\n                return map;\n            };\n            return extractEmbeddedColumnValue(propertyNames, {});\n\n        } else { // no embeds - no problems. Simply return column property name and its value of the entity\n\n            // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n            if (this.generationStrategy === \"increment\" && this.type === \"bigint\")\n                value = String(value);\n\n            return { [this.propertyName]: value };\n        }\n    }\n\n    /**\n     * Extracts column value and returns its column name with this value in a literal object.\n     * If column is in embedded (or recursive embedded) it returns complex literal object.\n     *\n     * Examples what this method can return depend if this column is in embeds.\n     * { id: 1 } or { title: \"hello\" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }\n     */\n    getEntityValueMap(entity: ObjectLiteral): ObjectLiteral {\n\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (propertyNames: string[], value: ObjectLiteral, map: ObjectLiteral): any => {\n                const propertyName = propertyNames.shift();\n                if (propertyName) {\n                    map[propertyName] = {};\n                    extractEmbeddedColumnValue(propertyNames, value ? value[propertyName] : undefined, map[propertyName]);\n                    return map;\n                }\n                map[this.propertyName] = value ? value[this.propertyName] : undefined;\n                return map;\n            };\n            return extractEmbeddedColumnValue(propertyNames, entity, {});\n\n        } else { // no embeds - no problems. Simply return column property name and its value of the entity\n            if (this.relationMetadata && entity[this.propertyName] && entity[this.propertyName] instanceof Object) {\n                const map = this.relationMetadata.joinColumns.reduce((map, joinColumn) => {\n                    return OrmUtils.mergeDeep(map, joinColumn.referencedColumn!.getEntityValueMap(entity[this.propertyName]));\n                }, {});\n                return { [this.propertyName]: map };\n            } else {\n                return { [this.propertyName]: entity[this.propertyName] };\n            }\n        }\n    }\n\n    /**\n     * Extracts column value from the given entity.\n     * If column is in embedded (or recursive embedded) it extracts its value from there.\n     */\n     getEntityValue(entity: ObjectLiteral): any|undefined {\n        // if (entity === undefined || entity === null) return undefined; // uncomment if needed\n\n        // extract column value from embeddeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n\n            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n            const extractEmbeddedColumnValue = (propertyNames: string[], value: ObjectLiteral): any => {\n                const propertyName = propertyNames.shift();\n                return propertyName && value ? extractEmbeddedColumnValue(propertyNames, value[propertyName]) : value;\n            };\n\n            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n            const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);\n            if (embeddedObject) {\n                if (this.relationMetadata && this.referencedColumn && this.isVirtual) {\n                    const relatedEntity = this.relationMetadata.getEntityValue(embeddedObject);\n                    if (relatedEntity && relatedEntity instanceof Object)\n                        return this.referencedColumn.getEntityValue(relatedEntity);\n                }\n                return embeddedObject[this.propertyName];\n            }\n            return undefined;\n\n        } else { // no embeds - no problems. Simply return column name by property name of the entity\n            if (this.relationMetadata && this.referencedColumn && this.isVirtual) {\n                const relatedEntity = this.relationMetadata.getEntityValue(entity);\n                if (relatedEntity && relatedEntity instanceof Object)\n                    return this.referencedColumn.getEntityValue(relatedEntity);\n            }\n            return entity[this.propertyName];\n        }\n    }\n\n    /**\n     * Sets given entity's column value.\n     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n     */\n    setEntityValue(entity: ObjectLiteral, value: any): void {\n        if (this.embeddedMetadata) {\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const extractEmbeddedColumnValue = (embeddedMetadatas: EmbeddedMetadata[], map: ObjectLiteral): any => {\n                // if (!object[embeddedMetadata.propertyName])\n                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n\n                const embeddedMetadata = embeddedMetadatas.shift();\n                if (embeddedMetadata) {\n                    if (!map[embeddedMetadata.propertyName])\n                        map[embeddedMetadata.propertyName] = embeddedMetadata.create();\n\n                    extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);\n                    return map;\n                }\n                map[this.propertyName] = value;\n                return map;\n            };\n            return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);\n\n        } else {\n            entity[this.propertyName] = value;\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Builder Methods\n    // ---------------------------------------------------------------------\n\n    build(connection: Connection): this {\n        this.propertyPath = this.buildPropertyPath();\n        this.databaseName = this.buildDatabaseName(connection);\n        this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, []);\n        return this;\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    protected buildPropertyPath(): string {\n        let path = \"\";\n        if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length)\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n\n        path += this.propertyName;\n\n        // we add reference column to property path only if this column is virtual\n        // because if its not virtual it means user defined a real column for this relation\n        if (this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName)\n            path += \".\" + this.referencedColumn.propertyName;\n\n        return path;\n    }\n\n    protected buildDatabaseName(connection: Connection): string {\n        const propertyNames = this.embeddedMetadata ? this.embeddedMetadata.parentPrefixes : [];\n        return connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, propertyNames);\n    }\n\n}"],"sourceRoot":".."}