{"version":3,"file":"index.cjs.js","sources":["../../../dist/plugins/other/visitor-plugin-common/src/mappers.js","../../../dist/plugins/other/visitor-plugin-common/src/utils.js","../../../dist/plugins/other/introspection/src/index.js"],"sourcesContent":["export function isExternalMapperType(m) {\n    return !!m.import;\n}\nvar MapperKind;\n(function (MapperKind) {\n    MapperKind[MapperKind[\"Namespace\"] = 0] = \"Namespace\";\n    MapperKind[MapperKind[\"Default\"] = 1] = \"Default\";\n    MapperKind[MapperKind[\"Regular\"] = 2] = \"Regular\";\n})(MapperKind || (MapperKind = {}));\nfunction prepareLegacy(mapper) {\n    const items = mapper.split('#');\n    const isNamespace = items.length === 3;\n    const isDefault = items[1].trim() === 'default' || items[1].startsWith('default ');\n    const hasAlias = items[1].includes(' as ');\n    return {\n        items,\n        isDefault,\n        isNamespace,\n        hasAlias,\n    };\n}\nfunction prepare(mapper) {\n    const [source, path] = mapper.split('#');\n    const isNamespace = path.includes('.');\n    const isDefault = path.trim() === 'default' || path.startsWith('default ');\n    const hasAlias = path.includes(' as ');\n    return {\n        items: isNamespace ? [source, ...path.split('.')] : [source, path],\n        isDefault,\n        isNamespace,\n        hasAlias,\n    };\n}\nfunction isLegacyMode(mapper) {\n    return mapper.split('#').length === 3;\n}\nexport function parseMapper(mapper, gqlTypeName = null, suffix) {\n    if (isExternalMapper(mapper)) {\n        const { isNamespace, isDefault, hasAlias, items } = isLegacyMode(mapper) ? prepareLegacy(mapper) : prepare(mapper);\n        const mapperKind = isNamespace\n            ? MapperKind.Namespace\n            : isDefault\n                ? MapperKind.Default\n                : MapperKind.Regular;\n        function handleAlias(isDefault = false) {\n            const [importedType, aliasType] = items[1].split(/\\s+as\\s+/);\n            const type = maybeSuffix(aliasType);\n            return {\n                importElement: isDefault ? type : `${importedType} as ${type}`,\n                type: type,\n            };\n        }\n        function maybeSuffix(type) {\n            if (suffix) {\n                return addSuffix(type, suffix);\n            }\n            return type;\n        }\n        function handle() {\n            switch (mapperKind) {\n                // ./my/module#Namespace#Identifier\n                case MapperKind.Namespace: {\n                    const [, ns, identifier] = items;\n                    return {\n                        type: `${ns}.${identifier}`,\n                        importElement: ns,\n                    };\n                }\n                case MapperKind.Default: {\n                    // ./my/module#default as alias\n                    if (hasAlias) {\n                        return handleAlias(true);\n                    }\n                    const type = maybeSuffix(`${gqlTypeName}`);\n                    // ./my/module#default\n                    return {\n                        importElement: type,\n                        type,\n                    };\n                }\n                case MapperKind.Regular: {\n                    // ./my/module#Identifier as alias\n                    if (hasAlias) {\n                        return handleAlias();\n                    }\n                    const identifier = items[1];\n                    const type = maybeSuffix(identifier);\n                    // ./my/module#Identifier\n                    return {\n                        type,\n                        importElement: suffix ? `${identifier} as ${type}` : type,\n                    };\n                }\n            }\n        }\n        const { type, importElement } = handle();\n        return {\n            default: isDefault,\n            isExternal: true,\n            source: items[0],\n            type,\n            import: importElement.replace(/<(.*?)>/g, ''),\n        };\n    }\n    return {\n        isExternal: false,\n        type: mapper,\n    };\n}\nfunction addSuffix(element, suffix) {\n    const generic = element.indexOf('<');\n    if (generic === -1) {\n        return `${element}${suffix}`;\n    }\n    return `${element.slice(0, generic)}${suffix}${element.slice(generic)}`;\n}\nexport function isExternalMapper(value) {\n    return value.includes('#');\n}\nexport function transformMappers(rawMappers, mapperTypeSuffix) {\n    const result = {};\n    Object.keys(rawMappers).forEach(gqlTypeName => {\n        const mapperDef = rawMappers[gqlTypeName];\n        const parsedMapper = parseMapper(mapperDef, gqlTypeName, mapperTypeSuffix);\n        result[gqlTypeName] = parsedMapper;\n    });\n    return result;\n}\nexport function buildMapperImport(source, types, useTypeImports) {\n    if (!types || types.length === 0) {\n        return null;\n    }\n    const defaultType = types.find(t => t.asDefault === true);\n    let namedTypes = types.filter(t => !t.asDefault);\n    if (useTypeImports) {\n        if (defaultType) {\n            // default as Baz\n            namedTypes = [{ identifier: `default as ${defaultType.identifier}` }, ...namedTypes];\n        }\n        // { Foo, Bar as BarModel }\n        const namedImports = namedTypes.length ? `{ ${namedTypes.map(t => t.identifier).join(', ')} }` : '';\n        // { default as Baz, Foo, Bar as BarModel }\n        return `import type ${[namedImports].filter(Boolean).join(', ')} from '${source}';`;\n    }\n    // { Foo, Bar as BarModel }\n    const namedImports = namedTypes.length ? `{ ${namedTypes.map(t => t.identifier).join(', ')} }` : '';\n    // Baz\n    const defaultImport = defaultType ? defaultType.identifier : '';\n    // Baz, { Foo, Bar as BarModel }\n    return `import ${[defaultImport, namedImports].filter(Boolean).join(', ')} from '${source}';`;\n}\n//# sourceMappingURL=mappers.js.map","import { Kind, isScalarType, isEqualType, isNonNullType, isObjectType, isListType, isAbstractType, } from 'graphql';\nimport { DEFAULT_SCALARS } from './scalars';\nimport { parseMapper } from './mappers';\nexport const getConfigValue = (value, defaultValue) => {\n    if (value === null || value === undefined) {\n        return defaultValue;\n    }\n    return value;\n};\nexport function quoteIfNeeded(array, joinWith = ' & ') {\n    if (array.length === 0) {\n        return '';\n    }\n    else if (array.length === 1) {\n        return array[0];\n    }\n    else {\n        return `(${array.join(joinWith)})`;\n    }\n}\nexport function block(array) {\n    return array && array.length !== 0 ? '{\\n' + array.join('\\n') + '\\n}' : '';\n}\nexport function wrapWithSingleQuotes(value, skipNumericCheck = false) {\n    if (skipNumericCheck) {\n        if (typeof value === 'number') {\n            return `${value}`;\n        }\n        else {\n            return `'${value}'`;\n        }\n    }\n    if (typeof value === 'number' ||\n        (typeof value === 'string' && !isNaN(parseInt(value)) && parseFloat(value).toString() === value)) {\n        return `${value}`;\n    }\n    return `'${value}'`;\n}\nexport function breakLine(str) {\n    return str + '\\n';\n}\nexport function indent(str, count = 1) {\n    return new Array(count).fill('  ').join('') + str;\n}\nexport function indentMultiline(str, count = 1) {\n    const indentation = new Array(count).fill('  ').join('');\n    const replaceWith = '\\n' + indentation;\n    return indentation + str.replace(/\\n/g, replaceWith);\n}\nexport function transformComment(comment, indentLevel = 0) {\n    if (!comment || comment === '') {\n        return '';\n    }\n    if (isStringValueNode(comment)) {\n        comment = comment.value;\n    }\n    comment = comment.split('*/').join('*\\\\/');\n    let lines = comment.split('\\n');\n    if (lines.length === 1) {\n        return indent(`/** ${lines[0]} */\\n`, indentLevel);\n    }\n    lines = ['/**', ...lines.map(line => ` * ${line}`), ' */\\n'];\n    return lines.map(line => indent(line, indentLevel)).join('\\n');\n}\nexport class DeclarationBlock {\n    constructor(_config) {\n        this._config = _config;\n        this._decorator = null;\n        this._export = false;\n        this._name = null;\n        this._kind = null;\n        this._methodName = null;\n        this._content = null;\n        this._block = null;\n        this._nameGenerics = null;\n        this._comment = null;\n        this._ignoreBlockWrapper = false;\n        this._config = {\n            blockWrapper: '',\n            blockTransformer: block => block,\n            enumNameValueSeparator: ':',\n            ...this._config,\n        };\n    }\n    withDecorator(decorator) {\n        this._decorator = decorator;\n        return this;\n    }\n    export(exp = true) {\n        if (!this._config.ignoreExport) {\n            this._export = exp;\n        }\n        return this;\n    }\n    asKind(kind) {\n        this._kind = kind;\n        return this;\n    }\n    withComment(comment) {\n        const nonEmptyComment = isStringValueNode(comment) ? !!comment.value : !!comment;\n        if (nonEmptyComment) {\n            this._comment = transformComment(comment, 0);\n        }\n        return this;\n    }\n    withMethodCall(methodName, ignoreBlockWrapper = false) {\n        this._methodName = methodName;\n        this._ignoreBlockWrapper = ignoreBlockWrapper;\n        return this;\n    }\n    withBlock(block) {\n        this._block = block;\n        return this;\n    }\n    withContent(content) {\n        this._content = content;\n        return this;\n    }\n    withName(name, generics = null) {\n        this._name = name;\n        this._nameGenerics = generics;\n        return this;\n    }\n    get string() {\n        let result = '';\n        if (this._decorator) {\n            result += this._decorator + '\\n';\n        }\n        if (this._export) {\n            result += 'export ';\n        }\n        if (this._kind) {\n            let extra = '';\n            let name = '';\n            if (['type', 'const', 'var', 'let'].includes(this._kind)) {\n                extra = '= ';\n            }\n            if (this._name) {\n                name = this._name + (this._nameGenerics || '') + ' ';\n            }\n            result += this._kind + ' ' + name + extra;\n        }\n        if (this._block) {\n            if (this._content) {\n                result += this._content;\n            }\n            const blockWrapper = this._ignoreBlockWrapper ? '' : this._config.blockWrapper;\n            const before = '{' + blockWrapper;\n            const after = blockWrapper + '}';\n            const block = [before, this._block, after].filter(val => !!val).join('\\n');\n            if (this._methodName) {\n                result += `${this._methodName}(${this._config.blockTransformer(block)})`;\n            }\n            else {\n                result += this._config.blockTransformer(block);\n            }\n        }\n        else if (this._content) {\n            result += this._content;\n        }\n        else if (this._kind) {\n            result += this._config.blockTransformer('{}');\n        }\n        return ((this._comment ? this._comment : '') +\n            result +\n            (this._kind === 'interface' || this._kind === 'enum' || this._kind === 'namespace' || this._kind === 'function'\n                ? ''\n                : ';') +\n            '\\n');\n    }\n}\nexport function getBaseTypeNode(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE || typeNode.kind === Kind.NON_NULL_TYPE) {\n        return getBaseTypeNode(typeNode.type);\n    }\n    return typeNode;\n}\nexport function convertNameParts(str, func, removeUnderscore = false) {\n    if (removeUnderscore) {\n        return func(str);\n    }\n    return str\n        .split('_')\n        .map(s => func(s))\n        .join('_');\n}\nexport function buildScalars(schema, scalarsMapping, defaultScalarsMapping = DEFAULT_SCALARS, defaultScalarType = 'any') {\n    const result = {};\n    Object.keys(defaultScalarsMapping).forEach(name => {\n        result[name] = parseMapper(defaultScalarsMapping[name]);\n    });\n    if (schema) {\n        const typeMap = schema.getTypeMap();\n        Object.keys(typeMap)\n            .map(typeName => typeMap[typeName])\n            .filter(type => isScalarType(type))\n            .map((scalarType) => {\n            const name = scalarType.name;\n            if (typeof scalarsMapping === 'string') {\n                const value = parseMapper(scalarsMapping + '#' + name, name);\n                result[name] = value;\n            }\n            else if (scalarsMapping && typeof scalarsMapping[name] === 'string') {\n                const value = parseMapper(scalarsMapping[name], name);\n                result[name] = value;\n            }\n            else if (scalarsMapping && scalarsMapping[name]) {\n                result[name] = {\n                    isExternal: false,\n                    type: JSON.stringify(scalarsMapping[name]),\n                };\n            }\n            else if (!defaultScalarsMapping[name]) {\n                result[name] = {\n                    isExternal: false,\n                    type: defaultScalarType,\n                };\n            }\n        });\n    }\n    else if (scalarsMapping) {\n        if (typeof scalarsMapping === 'string') {\n            throw new Error('Cannot use string scalars mapping when building without a schema');\n        }\n        Object.keys(scalarsMapping).forEach(name => {\n            if (typeof scalarsMapping[name] === 'string') {\n                const value = parseMapper(scalarsMapping[name], name);\n                result[name] = value;\n            }\n            else {\n                result[name] = {\n                    isExternal: false,\n                    type: JSON.stringify(scalarsMapping[name]),\n                };\n            }\n        });\n    }\n    return result;\n}\nfunction isStringValueNode(node) {\n    return node && typeof node === 'object' && node.kind === Kind.STRING;\n}\nexport function isRootType(type, schema) {\n    return (isEqualType(type, schema.getQueryType()) ||\n        isEqualType(type, schema.getMutationType()) ||\n        isEqualType(type, schema.getSubscriptionType()));\n}\nexport function getRootTypeNames(schema) {\n    return [schema.getQueryType(), schema.getMutationType(), schema.getSubscriptionType()]\n        .filter(t => t)\n        .map(t => t.name);\n}\nexport function stripMapperTypeInterpolation(identifier) {\n    return identifier.trim().replace(/<{.*}>/, '');\n}\nexport const OMIT_TYPE = 'export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;';\nexport const REQUIRE_FIELDS_TYPE = `export type RequireFields<T, K extends keyof T> = { [X in Exclude<keyof T, K>]?: T[X] } & { [P in K]-?: NonNullable<T[P]> };`;\nexport function mergeSelectionSets(selectionSet1, selectionSet2) {\n    const newSelections = [...selectionSet1.selections];\n    for (const selection2 of selectionSet2.selections) {\n        if (selection2.kind === 'FragmentSpread') {\n            newSelections.push(selection2);\n            continue;\n        }\n        if (selection2.kind !== 'Field') {\n            throw new TypeError('Invalid state.');\n        }\n        const match = newSelections.find(selection1 => selection1.kind === 'Field' && getFieldNodeNameValue(selection1) === getFieldNodeNameValue(selection2));\n        if (match) {\n            // recursively merge all selection sets\n            if (match.kind === 'Field' && match.selectionSet && selection2.selectionSet) {\n                mergeSelectionSets(match.selectionSet, selection2.selectionSet);\n            }\n            continue;\n        }\n        newSelections.push(selection2);\n    }\n    // replace existing selections\n    selectionSet1.selections = newSelections;\n}\nexport const getFieldNodeNameValue = (node) => {\n    return (node.alias || node.name).value;\n};\nexport function separateSelectionSet(selections) {\n    return {\n        fields: selections.filter(s => s.kind === Kind.FIELD),\n        inlines: selections.filter(s => s.kind === Kind.INLINE_FRAGMENT),\n        spreads: selections.filter(s => s.kind === Kind.FRAGMENT_SPREAD),\n    };\n}\nexport function getPossibleTypes(schema, type) {\n    if (isListType(type) || isNonNullType(type)) {\n        return getPossibleTypes(schema, type.ofType);\n    }\n    else if (isObjectType(type)) {\n        return [type];\n    }\n    else if (isAbstractType(type)) {\n        return schema.getPossibleTypes(type);\n    }\n    return [];\n}\nexport function hasConditionalDirectives(directives) {\n    if (directives.length === 0)\n        return false;\n    for (const directive of directives) {\n        if (['skip', 'include'].includes(directive.name.value)) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function wrapTypeWithModifiers(baseType, type, options) {\n    let currentType = type;\n    const modifiers = [];\n    while (currentType) {\n        if (isNonNullType(currentType)) {\n            currentType = currentType.ofType;\n        }\n        else {\n            modifiers.push(options.wrapOptional);\n        }\n        if (isListType(currentType)) {\n            modifiers.push(options.wrapArray);\n            currentType = currentType.ofType;\n        }\n        else {\n            break;\n        }\n    }\n    return modifiers.reduceRight((result, modifier) => modifier(result), baseType);\n}\n//# sourceMappingURL=utils.js.map","import { introspectionFromSchema } from 'graphql';\nimport { removeFederation } from '@graphql-codegen/plugin-helpers';\nimport { extname } from 'path';\nimport { getConfigValue } from '../../visitor-plugin-common/src/utils';\nexport const plugin = async (schema, _documents, pluginConfig) => {\n    const cleanSchema = pluginConfig.federation ? removeFederation(schema) : schema;\n    const descriptions = getConfigValue(pluginConfig.descriptions, true);\n    const directiveIsRepeatable = getConfigValue(pluginConfig.directiveIsRepeatable, true);\n    const schemaDescription = getConfigValue(pluginConfig.schemaDescription, undefined);\n    const specifiedByUrl = getConfigValue(pluginConfig.specifiedByUrl, undefined);\n    const introspection = introspectionFromSchema(cleanSchema, {\n        descriptions,\n        directiveIsRepeatable,\n        schemaDescription,\n        specifiedByUrl,\n    });\n    return pluginConfig.minify ? JSON.stringify(introspection) : JSON.stringify(introspection, null, 2);\n};\nexport const validate = async (schema, documents, config, outputFile) => {\n    if (extname(outputFile) !== '.json') {\n        throw new Error(`Plugin \"introspection\" requires extension to be \".json\"!`);\n    }\n};\n//# sourceMappingURL=index.js.map"],"names":["removeFederation","introspectionFromSchema","extname"],"mappings":";;;;;;;;AAGA,IAAI,UAAU,CAAC;AACf,CAAC,UAAU,UAAU,EAAE;AACvB,IAAI,UAAU,CAAC,UAAU,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC;AAC1D,IAAI,UAAU,CAAC,UAAU,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS,CAAC;AACtD,IAAI,UAAU,CAAC,UAAU,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS,CAAC;AACtD,CAAC,EAAE,UAAU,KAAK,UAAU,GAAG,EAAE,CAAC,CAAC;;ACL5B,MAAM,cAAc,GAAG,CAAC,KAAK,EAAE,YAAY,KAAK;AACvD,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,EAAE;AAC/C,QAAQ,OAAO,YAAY,CAAC;AAC5B,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;;ACJW,MAAC,MAAM,GAAG,OAAO,MAAM,EAAE,UAAU,EAAE,YAAY,KAAK;AAClE,IAAI,MAAM,WAAW,GAAG,YAAY,CAAC,UAAU,GAAGA,8BAAgB,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;AACpF,IAAI,MAAM,YAAY,GAAG,cAAc,CAAC,YAAY,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;AACzE,IAAI,MAAM,qBAAqB,GAAG,cAAc,CAAC,YAAY,CAAC,qBAAqB,EAAE,IAAI,CAAC,CAAC;AAC3F,IAAI,MAAM,iBAAiB,GAAG,cAAc,CAAC,YAAY,CAAC,iBAAiB,EAAE,SAAS,CAAC,CAAC;AACxF,IAAI,MAAM,cAAc,GAAG,cAAc,CAAC,YAAY,CAAC,cAAc,EAAE,SAAS,CAAC,CAAC;AAClF,IAAI,MAAM,aAAa,GAAGC,+BAAuB,CAAC,WAAW,EAAE;AAC/D,QAAQ,YAAY;AACpB,QAAQ,qBAAqB;AAC7B,QAAQ,iBAAiB;AACzB,QAAQ,cAAc;AACtB,KAAK,CAAC,CAAC;AACP,IAAI,OAAO,YAAY,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,aAAa,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AACxG,EAAE;AACU,MAAC,QAAQ,GAAG,OAAO,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,UAAU,KAAK;AACzE,IAAI,IAAIC,YAAO,CAAC,UAAU,CAAC,KAAK,OAAO,EAAE;AACzC,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,wDAAwD,CAAC,CAAC,CAAC;AACpF,KAAK;AACL;;;;;"}