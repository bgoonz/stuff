import { useVisuallyHidden } from "@react-aria/visually-hidden";
import { useMenuTrigger } from "@react-aria/menu";
import { useLabel } from "@react-aria/label";
import { useCollator } from "@react-aria/i18n";
import { setInteractionModality, useInteractionModality } from "@react-aria/interactions";
import { ListKeyboardDelegate, useTypeSelect } from "@react-aria/selection";
import _react, { useMemo } from "react";
import { chain, filterDOMProps, mergeProps, useId } from "@react-aria/utils";
import _babelRuntimeHelpersEsmExtends from "@babel/runtime/helpers/esm/extends";

/**
 * Provides the behavior and accessibility implementation for a select component.
 * A select displays a collapsible list of options and allows a user to select one of them.
 * @param props - Props for the select.
 * @param state - State for the select, as returned by `useListState`.
 */
export function useSelect(props, state, ref) {
  let {
    keyboardDelegate,
    isDisabled
  } = props; // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
  // When virtualized, the layout object will be passed in as a prop and override this.

  let collator = useCollator({
    usage: 'search',
    sensitivity: 'base'
  });
  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(state.collection, state.disabledKeys, null, collator), [keyboardDelegate, state.collection, state.disabledKeys, collator]);
  let {
    menuTriggerProps,
    menuProps
  } = useMenuTrigger({
    isDisabled,
    type: 'listbox'
  }, state, ref);

  let onKeyDown = e => {
    switch (e.key) {
      case 'ArrowLeft':
        {
          // prevent scrolling containers
          e.preventDefault();
          let key = state.selectedKey != null ? delegate.getKeyAbove(state.selectedKey) : delegate.getFirstKey();

          if (key) {
            state.setSelectedKey(key);
          }

          break;
        }

      case 'ArrowRight':
        {
          // prevent scrolling containers
          e.preventDefault();
          let key = state.selectedKey != null ? delegate.getKeyBelow(state.selectedKey) : delegate.getFirstKey();

          if (key) {
            state.setSelectedKey(key);
          }

          break;
        }
    }
  };

  let {
    typeSelectProps
  } = useTypeSelect({
    keyboardDelegate: delegate,
    selectionManager: state.selectionManager,

    onTypeSelect(key) {
      state.setSelectedKey(key);
    }

  });
  let {
    labelProps,
    fieldProps
  } = useLabel(_babelRuntimeHelpersEsmExtends({}, props, {
    labelElementType: 'span'
  }));
  typeSelectProps.onKeyDown = typeSelectProps.onKeyDownCapture;
  delete typeSelectProps.onKeyDownCapture;
  let domProps = filterDOMProps(props, {
    labelable: true
  });
  let triggerProps = mergeProps(typeSelectProps, menuTriggerProps, fieldProps);
  let valueId = useId();
  return {
    labelProps: _babelRuntimeHelpersEsmExtends({}, labelProps, {
      onClick: () => {
        if (!props.isDisabled) {
          ref.current.focus(); // Show the focus ring so the user knows where focus went

          setInteractionModality('keyboard');
        }
      }
    }),
    triggerProps: mergeProps(domProps, _babelRuntimeHelpersEsmExtends({}, triggerProps, {
      onKeyDown: chain(triggerProps.onKeyDown, onKeyDown, props.onKeyDown),
      onKeyUp: props.onKeyUp,
      'aria-labelledby': [triggerProps['aria-labelledby'], triggerProps['aria-label'] && !triggerProps['aria-labelledby'] ? triggerProps.id : null, valueId].filter(Boolean).join(' '),

      onFocus(e) {
        if (state.isFocused) {
          return;
        }

        if (props.onFocus) {
          props.onFocus(e);
        }

        state.setFocused(true);
      },

      onBlur(e) {
        if (state.isOpen) {
          return;
        }

        if (props.onBlur) {
          props.onBlur(e);
        }

        state.setFocused(false);
      }

    })),
    valueProps: {
      id: valueId
    },
    menuProps: _babelRuntimeHelpersEsmExtends({}, menuProps, {
      autoFocus: state.focusStrategy || true,
      shouldSelectOnPressUp: true,
      shouldFocusOnHover: true,
      disallowEmptySelection: true,
      onBlur: e => {
        if (e.currentTarget.contains(e.relatedTarget)) {
          return;
        }

        if (props.onBlur) {
          props.onBlur(e);
        }

        state.setFocused(false);
      },
      'aria-labelledby': [fieldProps['aria-labelledby'], triggerProps['aria-label'] && !fieldProps['aria-labelledby'] ? triggerProps.id : null].filter(Boolean).join(' ')
    })
  };
}

/**
 * Provides the behavior and accessibility implementation for a hidden `<select>` element, which
 * can be used in combination with `useSelect` to support browser form autofill, mobile form
 * navigation, and native HTML form submission.
 */
export function useHiddenSelect(props, state, triggerRef) {
  var _state$selectedKey;

  let {
    name,
    isDisabled
  } = props;
  let modality = useInteractionModality();
  let {
    visuallyHiddenProps
  } = useVisuallyHidden(); // In Safari, the <select> cannot have `display: none` or `hidden` for autofill to work.
  // In Firefox, there must be a <label> to identify the <select> whereas other browsers
  // seem to identify it just by surrounding text.
  // The solution is to use <VisuallyHidden> to hide the elements, which clips the elements to a
  // 1px rectangle. In addition, we hide from screen readers with aria-hidden, and make the <select>
  // non tabbable with tabIndex={-1}.
  //
  // In mobile browsers, there are next/previous buttons above the software keyboard for navigating
  // between fields in a form. These only support native form inputs that are tabbable. In order to
  // support those, an additional hidden input is used to marshall focus to the button. It is tabbable
  // except when the button is focused, so that shift tab works properly to go to the actual previous
  // input in the form. Using the <select> for this also works, but Safari on iOS briefly flashes
  // the native menu on focus, so this isn't ideal. A font-size of 16px or greater is required to
  // prevent Safari from zooming in on the input when it is focused.
  //
  // If the current interaction modality is null, then the user hasn't interacted with the page yet.
  // In this case, we set the tabIndex to -1 on the input element so that automated accessibility
  // checkers don't throw false-positives about focusable elements inside an aria-hidden parent.

  return {
    containerProps: _babelRuntimeHelpersEsmExtends({}, visuallyHiddenProps, {
      'aria-hidden': true
    }),
    inputProps: {
      type: 'text',
      tabIndex: modality == null || state.isFocused || state.isOpen ? -1 : 0,
      style: {
        fontSize: 16
      },
      onFocus: () => triggerRef.current.focus(),
      disabled: isDisabled
    },
    selectProps: {
      tabIndex: -1,
      disabled: isDisabled,
      name,
      size: state.collection.size,
      value: (_state$selectedKey = state.selectedKey) != null ? _state$selectedKey : '',
      onChange: e => state.setSelectedKey(e.target.value)
    }
  };
}
/**
 * Renders a hidden native `<select>` element, which can be used to support browser
 * form autofill, mobile form navigation, and native form submission.
 */

export function HiddenSelect(props) {
  let {
    state,
    triggerRef,
    label,
    name,
    isDisabled
  } = props;
  let {
    containerProps,
    inputProps,
    selectProps
  } = useHiddenSelect(props, state, triggerRef); // If used in a <form>, use a hidden input so the value can be submitted to a server.
  // If the collection isn't too big, use a hidden <select> element for this so that browser
  // autofill will work. Otherwise, use an <input type="hidden">.

  if (state.collection.size <= 300) {
    return /*#__PURE__*/_react.createElement("div", containerProps, /*#__PURE__*/_react.createElement("input", inputProps), /*#__PURE__*/_react.createElement("label", null, label, /*#__PURE__*/_react.createElement("select", selectProps, /*#__PURE__*/_react.createElement("option", null), [...state.collection.getKeys()].map(key => {
      let item = state.collection.getItem(key);

      if (item.type === 'item') {
        return /*#__PURE__*/_react.createElement("option", {
          key: item.key,
          value: item.key
        }, item.textValue);
      }
    }))));
  } else if (name) {
    return /*#__PURE__*/_react.createElement("input", {
      type: "hidden",
      name: name,
      disabled: isDisabled,
      value: state.selectedKey
    });
  }

  return null;
}
//# sourceMappingURL=module.js.map
