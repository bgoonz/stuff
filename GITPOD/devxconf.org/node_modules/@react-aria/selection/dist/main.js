var {
  useLocale,
  useCollator
} = require("@react-aria/i18n");

var {
  focusWithoutScrolling,
  isMac,
  mergeProps
} = require("@react-aria/utils");

var {
  focusSafely,
  getFocusableTreeWalker
} = require("@react-aria/focus");

var {
  useEffect,
  useRef,
  useMemo
} = require("react");

var _babelRuntimeHelpersExtends = $parcel$interopDefault(require("@babel/runtime/helpers/extends"));

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

/**
 * Handles typeahead interactions with collections.
 */
function useTypeSelect(options) {
  let {
    keyboardDelegate,
    selectionManager,
    onTypeSelect
  } = options;
  let state = useRef({
    search: '',
    timeout: null
  }).current;

  let onKeyDown = e => {
    let character = $c2e740eb44846c887b3b88306c61$var$getStringForKey(e.key);

    if (!character || e.ctrlKey || e.metaKey) {
      return;
    } // Do not propagate the Spacebar event if it's meant to be part of the search.
    // When we time out, the search term becomes empty, hence the check on length.
    // Trimming is to account for the case of pressing the Spacebar more than once,
    // which should cycle through the selection/deselection of the focused item.


    if (character === ' ' && state.search.trim().length > 0) {
      e.preventDefault();

      if (!('continuePropagation' in e)) {
        e.stopPropagation();
      }
    }

    state.search += character; // Use the delegate to find a key to focus.
    // Prioritize items after the currently focused item, falling back to searching the whole list.

    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey); // If no key found, search from the top.

    if (key == null) {
      key = keyboardDelegate.getKeyForSearch(state.search);
    }

    if (key != null) {
      selectionManager.setFocusedKey(key);

      if (onTypeSelect) {
        onTypeSelect(key);
      }
    }

    clearTimeout(state.timeout);
    state.timeout = setTimeout(() => {
      state.search = '';
    }, 500);
  };

  return {
    typeSelectProps: {
      // Using a capturing listener to catch the keydown event before
      // other hooks in order to handle the Spacebar event.
      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null
    }
  };
}

exports.useTypeSelect = useTypeSelect;

function $c2e740eb44846c887b3b88306c61$var$getStringForKey(key) {
  // If the key is of length 1, it is an ASCII value.
  // Otherwise, if there are no ASCII characters in the key name,
  // it is a Unicode character.
  // See https://www.w3.org/TR/uievents-key/
  if (key.length === 1 || !/^[A-Z]/i.test(key)) {
    return key;
  }

  return '';
}

function $f791fefd7189e0e4d903034fb2925$var$isCtrlKeyPressed(e) {
  if (isMac()) {
    return e.metaKey;
  }

  return e.ctrlKey;
}

/**
 * Handles interactions with selectable collections.
 */
function useSelectableCollection(options) {
  let {
    selectionManager: manager,
    keyboardDelegate: delegate,
    ref,
    autoFocus = false,
    shouldFocusWrap = false,
    disallowEmptySelection = false,
    disallowSelectAll = false,
    selectOnFocus = false,
    disallowTypeAhead = false,
    shouldUseVirtualFocus,
    allowsTabNavigation = false
  } = options;
  let {
    direction
  } = useLocale();

  let onKeyDown = e => {
    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes
    if (e.altKey && e.key === 'Tab') {
      e.preventDefault();
    } // Let child element (e.g. menu button) handle the event if the Alt key is pressed.
    // Keyboard events bubble through portals. Don't handle keyboard events
    // for elements outside the collection (e.g. menus).


    if (e.altKey || !ref.current.contains(e.target)) {
      return;
    }

    const navigateToKey = (key, childFocus) => {
      if (key != null) {
        manager.setFocusedKey(key, childFocus);

        if (e.shiftKey && manager.selectionMode === 'multiple') {
          manager.extendSelection(key);
        } else if (selectOnFocus) {
          manager.replaceSelection(key);
        }
      }
    };

    switch (e.key) {
      case 'ArrowDown':
        {
          if (delegate.getKeyBelow) {
            e.preventDefault();
            let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : delegate.getFirstKey == null ? void 0 : delegate.getFirstKey();

            if (nextKey == null && shouldFocusWrap) {
              nextKey = delegate.getFirstKey == null ? void 0 : delegate.getFirstKey(manager.focusedKey);
            }

            navigateToKey(nextKey);
          }

          break;
        }

      case 'ArrowUp':
        {
          if (delegate.getKeyAbove) {
            e.preventDefault();
            let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : delegate.getLastKey == null ? void 0 : delegate.getLastKey();

            if (nextKey == null && shouldFocusWrap) {
              nextKey = delegate.getLastKey == null ? void 0 : delegate.getLastKey(manager.focusedKey);
            }

            navigateToKey(nextKey);
          }

          break;
        }

      case 'ArrowLeft':
        {
          if (delegate.getKeyLeftOf) {
            e.preventDefault();
            let nextKey = delegate.getKeyLeftOf(manager.focusedKey);
            navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');
          }

          break;
        }

      case 'ArrowRight':
        {
          if (delegate.getKeyRightOf) {
            e.preventDefault();
            let nextKey = delegate.getKeyRightOf(manager.focusedKey);
            navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');
          }

          break;
        }

      case 'Home':
        if (delegate.getFirstKey) {
          e.preventDefault();
          let firstKey = delegate.getFirstKey(manager.focusedKey, $f791fefd7189e0e4d903034fb2925$var$isCtrlKeyPressed(e));
          manager.setFocusedKey(firstKey);

          if ($f791fefd7189e0e4d903034fb2925$var$isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {
            manager.extendSelection(firstKey);
          } else if (selectOnFocus) {
            manager.replaceSelection(firstKey);
          }
        }

        break;

      case 'End':
        if (delegate.getLastKey) {
          e.preventDefault();
          let lastKey = delegate.getLastKey(manager.focusedKey, $f791fefd7189e0e4d903034fb2925$var$isCtrlKeyPressed(e));
          manager.setFocusedKey(lastKey);

          if ($f791fefd7189e0e4d903034fb2925$var$isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {
            manager.extendSelection(lastKey);
          } else if (selectOnFocus) {
            manager.replaceSelection(lastKey);
          }
        }

        break;

      case 'PageDown':
        if (delegate.getKeyPageBelow) {
          e.preventDefault();
          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);
          navigateToKey(nextKey);
        }

        break;

      case 'PageUp':
        if (delegate.getKeyPageAbove) {
          e.preventDefault();
          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);
          navigateToKey(nextKey);
        }

        break;

      case 'a':
        if ($f791fefd7189e0e4d903034fb2925$var$isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {
          e.preventDefault();
          manager.selectAll();
        }

        break;

      case 'Escape':
        e.preventDefault();

        if (!disallowEmptySelection) {
          manager.clearSelection();
        }

        break;

      case 'Tab':
        {
          if (!allowsTabNavigation) {
            // There may be elements that are "tabbable" inside a collection (e.g. in a grid cell).
            // However, collections should be treated as a single tab stop, with arrow key navigation internally.
            // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.
            // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element
            // in the collection, so that the browser default behavior will apply starting from that element
            // rather than the currently focused one.
            if (e.shiftKey) {
              ref.current.focus();
            } else {
              let walker = getFocusableTreeWalker(ref.current, {
                tabbable: true
              });
              let next;
              let last;

              do {
                last = walker.lastChild();

                if (last) {
                  next = last;
                }
              } while (last);

              if (next && !next.contains(document.activeElement)) {
                focusWithoutScrolling(next);
              }
            }

            break;
          }
        }
    }
  };

  let onFocus = e => {
    if (manager.isFocused) {
      // If a focus event bubbled through a portal, reset focus state.
      if (!e.currentTarget.contains(e.target)) {
        manager.setFocused(false);
      }

      return;
    } // Focus events can bubble through portals. Ignore these events.


    if (!e.currentTarget.contains(e.target)) {
      return;
    }

    manager.setFocused(true);

    if (manager.focusedKey == null) {
      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.
      // Attempt to detect whether the user is tabbing forward or backward into the collection
      // and either focus the first or last item accordingly.
      let relatedTarget = e.relatedTarget;

      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) {
        var _manager$lastSelected;

        manager.setFocusedKey((_manager$lastSelected = manager.lastSelectedKey) != null ? _manager$lastSelected : delegate.getLastKey());
      } else {
        var _manager$firstSelecte;

        manager.setFocusedKey((_manager$firstSelecte = manager.firstSelectedKey) != null ? _manager$firstSelecte : delegate.getFirstKey());
      }
    }
  };

  let onBlur = e => {
    // Don't set blurred and then focused again if moving focus within the collection.
    if (!e.currentTarget.contains(e.relatedTarget)) {
      manager.setFocused(false);
    }
  };

  const autoFocusRef = useRef(autoFocus);
  useEffect(() => {
    if (autoFocusRef.current) {
      let focusedKey = null; // Check focus strategy to determine which item to focus

      if (autoFocus === 'first') {
        focusedKey = delegate.getFirstKey();
      }

      if (autoFocus === 'last') {
        focusedKey = delegate.getLastKey();
      } // If there are any selected keys, make the first one the new focus target


      let selectedKeys = manager.selectedKeys;

      if (selectedKeys.size) {
        focusedKey = selectedKeys.values().next().value;
      }

      manager.setFocused(true);
      manager.setFocusedKey(focusedKey); // If no default focus key is selected, focus the collection itself.

      if (focusedKey == null && !shouldUseVirtualFocus) {
        focusSafely(ref.current);
      }
    }

    autoFocusRef.current = false; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  let handlers = {
    onKeyDown,
    onFocus,
    onBlur,

    onMouseDown(e) {
      // Ignore events that bubbled through portals.
      if (e.currentTarget.contains(e.target)) {
        // Prevent focus going to the collection when clicking on the scrollbar.
        e.preventDefault();
      }
    }

  };
  let {
    typeSelectProps
  } = useTypeSelect({
    keyboardDelegate: delegate,
    selectionManager: manager
  });

  if (!disallowTypeAhead) {
    handlers = mergeProps(typeSelectProps, handlers);
  } // If nothing is focused within the collection, make the collection itself tabbable.
  // This will be marshalled to either the first or last item depending on where focus came from.
  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try
  // to move real DOM focus to the element anyway.


  let tabIndex;

  if (!shouldUseVirtualFocus) {
    tabIndex = manager.focusedKey == null ? 0 : -1;
  }

  return {
    collectionProps: _babelRuntimeHelpersExtends({}, handlers, {
      tabIndex
    })
  };
}

exports.useSelectableCollection = useSelectableCollection;

/**
 * Handles interactions with an item in a selectable collection.
 */
function useSelectableItem(options) {
  let {
    selectionManager: manager,
    key,
    ref,
    shouldSelectOnPressUp,
    isVirtualized,
    shouldUseVirtualFocus,
    focus
  } = options;

  let onSelect = e => manager.select(key, e); // Focus the associated DOM node when this item becomes the focusedKey


  let isFocused = key === manager.focusedKey;
  useEffect(() => {
    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {
      if (focus) {
        focus();
      } else {
        focusSafely(ref.current);
      }
    }
  }, [ref, isFocused, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]); // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused
  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver
  // on iOS 14 doesn't try to move real DOM focus to the item anyway.

  let itemProps = {};

  if (!shouldUseVirtualFocus) {
    itemProps = {
      tabIndex: isFocused ? 0 : -1,

      onFocus(e) {
        if (e.target === ref.current) {
          manager.setFocusedKey(key);
        }
      }

    };
  } // By default, selection occurs on pointer down. This can be strange if selecting an
  // item causes the UI to disappear immediately (e.g. menus).
  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.
  // onPress requires a pointer down event on the same element as pointer up. For menus,
  // we want to be able to have the pointer down on the trigger that opens the menu and
  // the pointer up on the menu item rather than requiring a separate press.
  // For keyboard events, selection still occurs on key down.


  if (shouldSelectOnPressUp) {
    itemProps.onPressStart = e => {
      if (e.pointerType === 'keyboard') {
        onSelect(e);
      }
    };

    itemProps.onPressUp = e => {
      if (e.pointerType !== 'keyboard') {
        onSelect(e);
      }
    };
  } else {
    // On touch, it feels strange to select on touch down, so we special case this.
    itemProps.onPressStart = e => {
      if (e.pointerType !== 'touch') {
        onSelect(e);
      }
    };

    itemProps.onPress = e => {
      if (e.pointerType === 'touch') {
        onSelect(e);
      }
    };
  }

  if (!isVirtualized) {
    itemProps['data-key'] = key;
  }

  return {
    itemProps
  };
}

exports.useSelectableItem = useSelectableItem;

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
class ListKeyboardDelegate {
  constructor(collection, disabledKeys, ref, collator) {
    this.collection = void 0;
    this.disabledKeys = void 0;
    this.ref = void 0;
    this.collator = void 0;
    this.collection = collection;
    this.disabledKeys = disabledKeys;
    this.ref = ref;
    this.collator = collator;
  }

  getKeyBelow(key) {
    key = this.collection.getKeyAfter(key);

    while (key != null) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyAfter(key);
    }
  }

  getKeyAbove(key) {
    key = this.collection.getKeyBefore(key);

    while (key != null) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyBefore(key);
    }
  }

  getFirstKey() {
    let key = this.collection.getFirstKey();

    while (key != null) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyAfter(key);
    }
  }

  getLastKey() {
    let key = this.collection.getLastKey();

    while (key != null) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyBefore(key);
    }
  }

  getItem(key) {
    return this.ref.current.querySelector("[data-key=\"" + key + "\"]");
  }

  getKeyPageAbove(key) {
    let menu = this.ref.current;
    let item = this.getItem(key);

    if (!item) {
      return null;
    }

    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);

    while (item && item.offsetTop > pageY) {
      key = this.getKeyAbove(key);
      item = this.getItem(key);
    }

    return key;
  }

  getKeyPageBelow(key) {
    let menu = this.ref.current;
    let item = this.getItem(key);

    if (!item) {
      return null;
    }

    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);

    while (item && item.offsetTop < pageY) {
      key = this.getKeyBelow(key);
      item = this.getItem(key);
    }

    return key;
  }

  getKeyForSearch(search, fromKey) {
    if (!this.collator) {
      return null;
    }

    let collection = this.collection;
    let key = fromKey || this.getFirstKey();

    while (key != null) {
      let item = collection.getItem(key);
      let substring = item.textValue.slice(0, search.length);

      if (item.textValue && this.collator.compare(substring, search) === 0) {
        return key;
      }

      key = this.getKeyBelow(key);
    }

    return null;
  }

}

exports.ListKeyboardDelegate = ListKeyboardDelegate;

/**
 * Handles interactions with a selectable list.
 */
function useSelectableList(props) {
  let {
    selectionManager,
    collection,
    disabledKeys,
    ref,
    keyboardDelegate,
    autoFocus,
    shouldFocusWrap,
    isVirtualized,
    disallowEmptySelection,
    selectOnFocus = false,
    disallowTypeAhead,
    shouldUseVirtualFocus,
    allowsTabNavigation
  } = props; // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
  // When virtualized, the layout object will be passed in as a prop and override this.

  let collator = useCollator({
    usage: 'search',
    sensitivity: 'base'
  });
  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(collection, disabledKeys, ref, collator), [keyboardDelegate, collection, disabledKeys, ref, collator]); // If not virtualized, scroll the focused element into view when the focusedKey changes.
  // When virtualized, Virtualizer handles this internally.

  useEffect(() => {
    if (!isVirtualized && selectionManager.focusedKey && ref != null && ref.current) {
      let element = ref.current.querySelector("[data-key=\"" + selectionManager.focusedKey + "\"]");

      if (element) {
        $e85d8307c59fae2ab45d73201aa19$var$scrollIntoView(ref.current, element);
      }
    }
  }, [isVirtualized, ref, selectionManager.focusedKey]);
  let {
    collectionProps
  } = useSelectableCollection({
    ref,
    selectionManager,
    keyboardDelegate: delegate,
    autoFocus,
    shouldFocusWrap,
    disallowEmptySelection,
    selectOnFocus,
    disallowTypeAhead,
    shouldUseVirtualFocus,
    allowsTabNavigation
  });
  return {
    listProps: collectionProps
  };
}
/**
 * Scrolls `scrollView` so that `element` is visible.
 * Similar to `element.scrollIntoView({block: 'nearest'})` (not supported in Edge),
 * but doesn't affect parents above `scrollView`.
 */


exports.useSelectableList = useSelectableList;

function $e85d8307c59fae2ab45d73201aa19$var$scrollIntoView(scrollView, element) {
  let offsetX = $e85d8307c59fae2ab45d73201aa19$var$relativeOffset(scrollView, element, 'left');
  let offsetY = $e85d8307c59fae2ab45d73201aa19$var$relativeOffset(scrollView, element, 'top');
  let width = element.offsetWidth;
  let height = element.offsetHeight;
  let x = scrollView.scrollLeft;
  let y = scrollView.scrollTop;
  let maxX = x + scrollView.offsetWidth;
  let maxY = y + scrollView.offsetHeight;

  if (offsetX <= x) {
    x = offsetX;
  } else if (offsetX + width > maxX) {
    x += offsetX + width - maxX;
  }

  if (offsetY <= y) {
    y = offsetY;
  } else if (offsetY + height > maxY) {
    y += offsetY + height - maxY;
  }

  scrollView.scrollLeft = x;
  scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */


function $e85d8307c59fae2ab45d73201aa19$var$relativeOffset(ancestor, child, axis) {
  const prop = axis === 'left' ? 'offsetLeft' : 'offsetTop';
  let sum = 0;

  while (child.offsetParent) {
    sum += child[prop];

    if (child.offsetParent === ancestor) {
      // Stop once we have found the ancestor we are interested in.
      break;
    } else if (child.offsetParent.contains(ancestor)) {
      // If the ancestor is not `position:relative`, then we stop at 
      // _its_ offset parent, and we subtract off _its_ offset, so that
      // we end up with the proper offset from child to ancestor.
      sum -= ancestor[prop];
      break;
    }

    child = child.offsetParent;
  }

  return sum;
}
//# sourceMappingURL=main.js.map
